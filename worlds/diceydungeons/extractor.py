# Extract item data from a Dicey Dungeons installation.
#
# This script scans a Dicey Dungeons installation folder for directories
# inside `data/text/scripts/diceydungeons/itempools`. 
# For each such directory it opens `vanilla.hx`, finds any array
# assignments to variables (except a variable named `vampireitem`) and
# collects all string literals from those arrays. The result is printed as a
# JSON array of unique strings.

# Author note: Copilot wrote this for me, but it works, so :3

from __future__ import annotations

import argparse
import json
import os
import sys
import re
from typing import Iterable, List, Set, Dict


def find_matching_bracket(s: str, start: int) -> int:
	"""Return index of matching ']' for the '[' at start, or -1 if not found.
	Handles quoted strings and escapes so brackets inside strings are ignored.
	"""
	i = start
	if s[i] != "[":
		return -1
	depth = 1
	i += 1
	in_string = False
	string_char = ""
	while i < len(s):
		ch = s[i]
		if in_string:
			if ch == "\\":
				i += 2
				continue
			if ch == string_char:
				in_string = False
				string_char = ""
			i += 1
			continue
		if ch == '"' or ch == "'":
			in_string = True
			string_char = ch
			i += 1
			continue
		if ch == "[":
			depth += 1
		elif ch == "]":
			depth -= 1
			if depth == 0:
				return i
		i += 1
	return -1


def extract_strings_from_array_content(content: str) -> List[str]:
	# Match both single- and double-quoted strings, respectful of escapes.
	pattern = re.compile(r'"((?:\\.|[^"\\])*)"|\'((?:\\.|[^\\\'])*)\'')
	results: List[str] = []
	for m in pattern.finditer(content):
		s = m.group(1) if m.group(1) is not None else m.group(2)
		try:
			decoded = bytes(s, "utf-8").decode("unicode_escape")
		except Exception:
			decoded = s
		results.append(decoded)
	return results

# TODO: "tradeoffer" itempool has "any" in it (not a real equip) but excluding it removes others? Investigate.
def parse_vanilla_file(path: str, exclude_vars: list[str] = ["vampireitem", "tradeoffer"]) -> Set[str]:
	text = open(path, "r", encoding="utf-8", errors="ignore").read()
	results: Set[str] = set()

	# Find variable assignments of form: name = [ ... ]
	var_assign_pattern = re.compile(r"([A-Za-z_]\w*)\s*=\s*\[")
	for m in var_assign_pattern.finditer(text):
		varname = m.group(1)
		if varname in exclude_vars:
			continue
		start_idx = m.end() - 1  # position of '['
		end_idx = find_matching_bracket(text, start_idx)
		if end_idx == -1:
			continue
		array_content = text[start_idx + 1 : end_idx]
		for s in extract_strings_from_array_content(array_content):
			if s:
				results.add(s)
	return results


def collect_from_itempools(itempools_dir: str, prefix: str) -> List[str]:
	if not os.path.isdir(itempools_dir):
		raise FileNotFoundError(f"Directory not found: {itempools_dir}")
	collected: Set[str] = set()
	for name in os.listdir(itempools_dir):
		if not name.lower().startswith(prefix.lower()):
			continue
		subdir = os.path.join(itempools_dir, name)
		if not os.path.isdir(subdir):
			continue
		vanilla = os.path.join(subdir, "vanilla.hx")
		if not os.path.isfile(vanilla):
			continue
		try:
			items = parse_vanilla_file(vanilla)
		except Exception:
			continue
		collected.update(items)
	return sorted(collected)


def main(argv: Iterable[str] | None = None) -> int:
	parser = argparse.ArgumentParser(
		description=(
			"Extract unique strings from warrior vanilla.hx files in Dicey Dungeons"
		)
	)
	default_path = r"C:\Program Files (x86)\Steam\steamapps\common\Dicey Dungeons\data\text\scripts\diceydungeons\itempools"
	parser.add_argument(
		"path",
		nargs="?",
		default=default_path,
		help=f"Path to the itempools directory (default: {default_path})",
	)
	parser.add_argument(
		"--format",
		choices=("json", "py"),
		default="json",
		help="Output format: json (default) or py (Python list literal)",
	)
	args = parser.parse_args(list(argv) if argv is not None else None)
	prefixes = ["warrior", "thief", "witch", "jester", "inventor", "robot"]
	results: Dict[str, List[str]] = {}
	try:
		for p in prefixes:
			results[p] = collect_from_itempools(args.path, p)
	except FileNotFoundError as e:
		print(str(e), file=sys.stderr)
		return 2

	out_path = os.path.join(os.path.dirname(__file__), "extracted_data.py")
	try:
		with open(out_path, "w", encoding="utf-8") as f:
			f.write("# Auto-generated by extractor.py\n")
			f.write("# Contains lists of items for each role\n\n")
			for p in prefixes:
				varname = f"{p}_items"
				f.write(f"{varname} = [\n")
				for s in results.get(p, []):
					f.write(f"    {s!r},\n")
				f.write("]\n\n")
			# Optional __all__ listing
			f.write("__all__ = [\n")
			for p in prefixes:
				f.write(f"    '{p}_items',\n")
			f.write("]\n")
	except Exception as e:
		print(f"Failed writing output file: {e}", file=sys.stderr)
		return 3

	print(f"Wrote extracted lists to: {out_path}")
	return 0


if __name__ == "__main__":
	raise SystemExit(main())

